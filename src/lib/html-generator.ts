import type { EditorElement } from '@/types/editor';
import { convertToInlineStyle } from './style-utils';

function generateElementHtml(element: EditorElement): string {
  const Tag = element.type;
  const styleString = convertToInlineStyle(element.styles);
  
  let attributesString = '';
  if (element.attributes) {
    attributesString = Object.entries(element.attributes)
      .filter(([, value]) => value !== undefined && value !== null && value !== "")
      .map(([key, value]) => `${key}="${value}"`)
      .join(' ');
  }

  const childrenHtml = element.children.map(generateElementHtml).join('');
  
  let content = element.content || '';
  if (Tag === 'img') { // Images are self-closing, content is not applicable in the same way
    return `<${Tag} style="${styleString}" ${attributesString} />`;
  }

  return `<${Tag} style="${styleString}" ${attributesString}>${content}${childrenHtml}</${Tag}>`;
}

function generatePageStyles(elements: EditorElement[], classPrefix = 'el-'): string {
  let styles = `body { margin: 0; font-family: var(--font-geist-sans, sans-serif); background-color: hsl(var(--background)); color: hsl(var(--foreground)); }\n`; // Basic body styles
  
  function collectStylesRecursive(els: EditorElement[], currentStyles: string[]): void {
    els.forEach(el => {
      // For simplicity, we are using inline styles generated by generateElementHtml.
      // A more advanced approach would generate class-based CSS here.
      // For now, this function can be a placeholder or used for global styles.
      if (el.children.length > 0) {
        collectStylesRecursive(el.children, currentStyles);
      }
    });
  }
  
  const elementSpecificStyles: string[] = [];
  collectStylesRecursive(elements, elementSpecificStyles);
  styles += elementSpecificStyles.join('\n');
  
  return styles;
}


export function generateHtmlDocument(elements: EditorElement[], pageTitle: string = "Code Canvas Export"): string {
  const bodyContent = elements.map(generateElementHtml).join('\n    ');
  // const pageStyles = generatePageStyles(elements); // Using inline styles for now for simplicity. Revisit for class-based.

  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${pageTitle}</title>
    <style>
      body { 
        margin: 0; 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
        /* These CSS variables would ideally be defined or replaced if not using inline styles */
        --background: 220 13% 95%;
        --foreground: 215 25% 27%;
        background-color: hsl(var(--background)); 
        color: hsl(var(--foreground)); 
      }
      /* ${pageStyles} */ /* Removed as using inline styles */
    </style>
</head>
<body>
    ${bodyContent}
</body>
</html>`;
}

export function downloadHtmlFile(htmlContent: string, filename: string = "code-canvas-page.html"): void {
  const blob = new Blob([htmlContent], { type: 'text/html' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(link.href);
}
